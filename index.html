<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>WEB VISION - 全ウェブプロキシ</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    #proxyInterface { margin-bottom: 20px; }
    input[type="text"] { width: 300px; }
    button { padding: 6px 12px; font-size: 14px; }
    /* 「プロキシインターフェースに戻る」リンク用スタイル */
    .backLink {
      position: fixed;
      top: 0;
      left: 0;
      background-color: rgba(255,255,255,0.8);
      padding: 10px;
      z-index: 9999;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="proxyInterface">
    <h1>WEB VISION v7h1>
    <p>アクセスしたい URL を入力してください：</p>
    <form id="proxyForm">
      <input type="text" id="urlInput" placeholder="https://example.com" required>
      <button type="submit">アクセス</button>
    </form>
    <p>
      ※ このサービスは外部プロキシ（cors-anywhere）を利用しています。<br>
      著作権、利用規約、セキュリティリスクに十分ご注意ください。
    </p>
  </div>

  <script>
  (function proxyMain() {
    // 外部プロキシサービスのURL（利用制限や事前アクセス許可に注意）
    const externalProxy = "https://cors-anywhere.herokuapp.com/";
    // 自身のプロキシモードURLのベース（GitHub Pages 上の URL）
    const baseProxyURL = window.location.origin + window.location.pathname + "?url=";
  
    // URLパラメータ "url" をチェック（プロキシモードか否かを判断）
    const params = new URLSearchParams(window.location.search);
    const proxiedURL = params.get("url");
  
    if (proxiedURL) {
      // プロキシモードの場合、対象ページを取得して表示
      fetchContentAndRender(proxiedURL);
    } else {
      // 初期表示（プロキシインターフェース）：フォーム送信でプロキシモードに移行
      document.getElementById("proxyForm").addEventListener("submit", function(e) {
        e.preventDefault();
        const url = document.getElementById("urlInput").value;
        if(url) {
          window.location.href = baseProxyURL + encodeURIComponent(url);
        }
      });
    }
  
    function fetchContentAndRender(url) {
      fetch(externalProxy + url)
        .then(response => {
          if (!response.ok) {
            throw new Error("ネットワークエラー: " + response.status);
          }
          return response.text();
        })
        .then(htmlText => {
          // パースして DOM として扱う
          const parser = new DOMParser();
          const doc = parser.parseFromString(htmlText, "text/html");
  
          // <base> タグを head の先頭に確実に挿入する
          let head = doc.querySelector("head");
          if (head) {
            const existingBase = head.querySelector("base");
            if (existingBase) {
              existingBase.remove();
            }
            const baseEl = doc.createElement("base");
            baseEl.href = url;
            head.insertBefore(baseEl, head.firstChild);
          } else {
            const newHead = doc.createElement("head");
            const baseEl = doc.createElement("base");
            baseEl.href = url;
            newHead.appendChild(baseEl);
            doc.documentElement.insertBefore(newHead, doc.documentElement.firstChild);
          }
  
          // リンク・画像・スクリプト・CSS・iframe の属性を書き換え
          rewriteDocument(doc, url);
          // プロキシ処理のスクリプトを再注入（以降のリンクもプロキシ経由に）
          injectProxyScript(doc);
          // 「プロキシインターフェースに戻る」リンクを挿入
          injectBackLink(doc);
  
          // 新しい HTML をシリアライズして、現在のページを置き換える
          const serializer = new XMLSerializer();
          const newHTML = serializer.serializeToString(doc);
          document.open();
          document.write(newHTML);
          document.close();
        })
        .catch(err => {
          document.body.innerHTML = "<p>エラー: " + err.message + "</p>";
        });
    }
  
    function rewriteDocument(doc, baseUrl) {
      // 書き換えルール：対象要素と属性
      const rules = [
        { selector: "a", attr: "href" },
        { selector: "img", attr: "src" },
        { selector: "script", attr: "src" },
        { selector: "link", attr: "href" },
        { selector: "iframe", attr: "src" }
      ];
      rules.forEach(rule => {
        const elements = doc.querySelectorAll(rule.selector);
        elements.forEach(el => {
          const orig = el.getAttribute(rule.attr);
          if (orig) {
            try {
              const absUrl = new URL(orig, baseUrl).toString();
              // 書き換えた URL は常にこのプロキシを通るように
              el.setAttribute(rule.attr, baseProxyURL + encodeURIComponent(absUrl));
            } catch(e) {
              // 変換できなかった場合はそのまま
            }
          }
        });
      });
      // GET メソッドのフォームの action 属性も書き換え（POST は未対応）
      const forms = doc.querySelectorAll("form");
      forms.forEach(form => {
        let action = form.getAttribute("action") || baseUrl;
        try {
          const absUrl = new URL(action, baseUrl).toString();
          form.setAttribute("action", baseProxyURL + encodeURIComponent(absUrl));
        } catch(e) {}
      });
    }
  
    function injectProxyScript(doc) {
      const scriptEl = doc.createElement("script");
      // プロキシ処理全体を再注入する（これにより、以降のリンククリックもプロキシ経由に）
      scriptEl.textContent = "(" + proxyMain.toString() + ")();";
      // body の最後に追加
      doc.body.appendChild(scriptEl);
    }
  
    function injectBackLink(doc) {
      // 「プロキシインターフェースに戻る」リンクを固定表示で追加
      const backDiv = doc.createElement("div");
      backDiv.className = "backLink";
      backDiv.innerHTML = '<a href="' + window.location.origin + window.location.pathname + '">[プロキシインターフェースに戻る]</a>';
      doc.body.insertBefore(backDiv, doc.body.firstChild);
    }
  })();
  </script>
</body>
</html>
